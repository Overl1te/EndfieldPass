{% extends 'base.html' %}
{% load static i18n_tags %}

{% block title %}{% t "title.characters" %} | EndfieldPass{% endblock %}

{% block content %}
<section class="characters-page">
    <header class="page-header">
        <h1 class="characters-title">
            {% t "characters.title" %}
            <span
                class="characters-title-help"
                data-tooltip="Учитываются только выпавшие персонажи, полученные иным путем не считаются"
                aria-label="Учитываются только выпавшие персонажи, полученные иным путем не считаются"
            >?</span>
        </h1>
    </header>

    <section class="characters-grid">
        {% for character in characters %}
        <article
            class="character-card"
            data-character-card
            data-character-name="{{ character.name }}"
            data-character-aliases="{{ character.aliases|join:'|' }}"
            data-character-icon="{{ character.icon }}"
        >
            <div class="character-topline">
                <span class="character-element">
                    <img src="{% static 'img/type/' %}{{ character.element_icon }}" alt="{{ character.element_label }}" loading="lazy">
                    {{ character.element_label }}
                </span>
                {% if character.is_obtained %}
                <span class="character-status is-obtained" data-character-status>{% t "characters.obtained" %} &middot; {{ character.obtained_date }}</span>
                {% else %}
                <span class="character-status is-missing" data-character-status>{% t "characters.missing" %}</span>
                {% endif %}
            </div>

            <div class="character-avatar">
                <span class="character-potential" data-character-potential title="Потенциал">P0</span>
                <img
                    src="{% static 'img/characters/' %}{{ character.icon }}"
                    alt="{{ character.name }}"
                    loading="lazy"
                    onerror="this.hidden=true; this.parentElement.classList.add('fallback');"
                >
                <span class="character-fallback">{{ character.name|slice:":1" }}</span>
            </div>
            <h2>{{ character.name }}</h2>

            <div class="character-meta">
                <span class="character-meta-item character-meta-rarity">
                    {% t "characters.rarity" rarity=character.rarity %}
                </span>
                <span class="character-meta-item">
                    <img src="{% static 'img/weapon/' %}{{ character.weapon_icon }}" alt="{{ character.weapon_label }}" loading="lazy">
                    {{ character.weapon_label }}
                </span>
                <span class="character-meta-item">
                    <img src="{% static 'img/role/' %}{{ character.role_icon }}" alt="{{ character.role_label }}" loading="lazy">
                    {{ character.role_label }}
                </span>
            </div>
        </article>
        {% endfor %}
    </section>
</section>
<script>
(() => {
    const obtainedLabel = "{% t 'characters.obtained' %}";
    const missingLabel = "{% t 'characters.missing' %}";
    const unknownDateLabel = "{% t 'characters.date_unknown' %}";

    const normalize = (value) => {
        const source = String(value || "").trim().toLowerCase().normalize("NFKC");
        try {
            return source.replace(/[^\p{L}\p{N}]+/gu, "");
        } catch (_) {
            return source.replace(/[\W_]+/g, "");
        }
    };

    const formatDate = (timestamp) => {
        const value = Number(timestamp) || 0;
        if (!value) return unknownDateLabel;
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return unknownDateLabel;
        return new Intl.DateTimeFormat(undefined, {
            day: "2-digit",
            month: "2-digit",
            year: "numeric",
        }).format(date);
    };

    const buildObtainedMap = (pulls) => {
        const obtained = new Map();
        const sorted = [...pulls].sort((a, b) => (Number(a.gacha_ts) || 0) - (Number(b.gacha_ts) || 0));
        sorted.forEach((pull) => {
            const keys = [normalize(pull.char_name), normalize(pull.char_id)].filter(Boolean);
            keys.forEach((key) => {
                if (!obtained.has(key)) {
                    obtained.set(key, pull.gacha_ts || null);
                }
            });
        });
        return obtained;
    };

    const renderCharacters = () => {
        const historyApi = window.endfieldPassHistory;
        if (!historyApi || typeof historyApi.getLatestPulls !== "function") return;
        const pulls = historyApi.getLatestPulls() || [];
        const obtainedMap = buildObtainedMap(pulls);
        const alwaysOwnedIcons = new Set(["Endministrator.png", "Chen-Qianyu.png", "perlica.png"]);
        const forcedConstBonusIcons = new Set(["Chen-Qianyu.png", "perlica.png"]);
        const normalizedPullKeySets = pulls.map((pull) => new Set([
            normalize(pull.char_name),
            normalize(pull.char_id),
        ].filter(Boolean)));
        const firstHeroTs = [...pulls]
            .map((pull) => Number(pull.gacha_ts) || 0)
            .filter((value) => value > 0)
            .sort((a, b) => a - b)[0] || null;

        document.querySelectorAll("[data-character-card]").forEach((card) => {
            const statusNode = card.querySelector("[data-character-status]");
            const potentialNode = card.querySelector("[data-character-potential]");
            const avatarNode = card.querySelector(".character-avatar");
            if (!statusNode) return;

            const iconName = String(card.dataset.characterIcon || "");
            const iconStem = iconName.split(".").slice(0, -1).join(".") || iconName;
            const aliases = String(card.dataset.characterAliases || "")
                .split("|")
                .map((value) => normalize(value))
                .filter(Boolean);
            const lookupKeys = new Set([
                normalize(card.dataset.characterName || ""),
                normalize(iconStem),
                ...aliases,
            ]);

            let dropCount = 0;
            normalizedPullKeySets.forEach((pullKeys) => {
                for (const key of lookupKeys) {
                    if (pullKeys.has(key)) {
                        dropCount += 1;
                        break;
                    }
                }
            });
            const forcedBonus = forcedConstBonusIcons.has(iconName) ? 1 : 0;
            const potential = Math.max(0, Math.min(5, (dropCount - 1) + forcedBonus));
            if (potentialNode) {
                potentialNode.textContent = `P${potential}`;
            }
            if (avatarNode) {
                avatarNode.classList.toggle("is-p5", potential >= 5);
            }

            let hasMatch = false;
            let matchedTs = null;
            lookupKeys.forEach((key) => {
                if (!obtainedMap.has(key)) return;
                hasMatch = true;
                if (matchedTs === null) matchedTs = obtainedMap.get(key);
            });

            if (alwaysOwnedIcons.has(iconName)) {
                hasMatch = true;
                matchedTs = firstHeroTs;
            }

            if (hasMatch) {
                statusNode.classList.remove("is-missing");
                statusNode.classList.add("is-obtained");
                statusNode.textContent = `${obtainedLabel} - ${formatDate(matchedTs)}`;
                return;
            }

            statusNode.classList.remove("is-obtained");
            statusNode.classList.add("is-missing");
            statusNode.textContent = missingLabel;
        });
    };

    const bootCharacters = () => {
        renderCharacters();
        window.addEventListener("endfieldpass:history-updated", renderCharacters);
    };

    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", bootCharacters, { once: true });
    } else {
        bootCharacters();
    }
})();
</script>
{% endblock %}
