{% load static i18n_tags %}
<!DOCTYPE html>
<html lang="{{ current_lang }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}EndfieldPass{% endblock %}</title>
    <link rel="icon" type="image/png" href="{% static 'img/logo.png' %}">
    <link rel="apple-touch-icon" href="{% static 'img/logo.png' %}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{% static 'css/main.css' %}">
</head>
<body>
    <div class="layout">
        <aside class="sidebar">
            <div class="brand">
                <a href="{% url 'dashboard' %}" class="brand-link" aria-label="EndfieldPass">
                    <img src="{% static 'img/logo.png' %}" alt="EndfieldPass" class="brand-logo">
                </a>
                <div class="brand-text">
                    <span class="brand-sub">Endfield</span>
                    <span class="brand-main">Pass</span>
                </div>
            </div>
            <nav class="menu">
                <a href="{% url 'dashboard' %}" class="menu-item {% if request.resolver_match.url_name == 'dashboard' %}active{% endif %}">{% t "menu.home" %}</a>
                <a href="{% url 'characters_page' %}" class="menu-item {% if request.resolver_match.url_name == 'characters_page' %}active{% endif %}">{% t "menu.characters" %}</a>
                <a href="{% url 'import_page' %}" class="menu-item {% if request.resolver_match.url_name == 'import_page' or request.resolver_match.url_name == 'import_view' %}active{% endif %}">{% t "menu.import" %}</a>
                <a href="{% url 'settings_page' %}" class="menu-item {% if request.resolver_match.url_name == 'settings_page' or request.resolver_match.url_name == 'import_history' or request.resolver_match.url_name == 'cloud_connect' or request.resolver_match.url_name == 'cloud_callback' or request.resolver_match.url_name == 'cloud_disconnect' or request.resolver_match.url_name == 'cloud_export' or request.resolver_match.url_name == 'cloud_import' %}active{% endif %}">{% t "menu.settings" %}</a>
            </nav>
            <div class="sidebar-footer">
                <form method="post" action="{% url 'set_site_language' %}" class="language-form">
                    {% csrf_token %}
                    <input type="hidden" name="next" value="{{ request.get_full_path }}">
                    <label for="site-language" class="language-label">{% t "language.selector" %}</label>
                    <select id="site-language" name="lang" onchange="this.form.submit()">
                        {% for option in language_options %}
                        <option value="{{ option.code }}" {% if current_lang == option.code %}selected{% endif %}>{{ option.label }}</option>
                        {% endfor %}
                    </select>
                </form>
            </div>
        </aside>

        <main class="content">
            <div class="content-body">
                {% block content %}{% endblock %}
            </div>
            <footer class="site-footer">
                <div class="site-footer-meta">
                    <span class="site-footer-title">EndfieldPass</span>
                    <span class="site-footer-copy">Â© 2026 Overl1te</span>
                </div>
                <nav class="site-footer-links" aria-label="{% t 'footer.aria' %}">
                    <a href="https://github.com/Overl1te/EndfieldPass" target="_blank" rel="noopener noreferrer">GitHub</a>
                    <a href="{% url 'privacy_policy' %}">{% t "footer.privacy" %}</a>
                    <a href="{% url 'cookies_policy' %}">{% t "footer.cookies" %}</a>
                </nav>
            </footer>
        </main>
    </div>
    <script>
    (() => {
        const HISTORY_KEY = "endfieldpass:history_payload_v1";
        const LEGACY_HISTORY_KEYS = ["endfieldpass:history_payload"];
        const CLOUD_PROVIDER_KEY = "endfieldpass:cloud_provider";
        const LAST_SYNC_TS_KEY = "endfieldpass:last_auto_sync_ts";
        const AUTO_SYNC_COOLDOWN_MS = 25000;

        const toInt = (value, fallback = 0) => {
            const parsed = Number.parseInt(String(value ?? ""), 10);
            return Number.isFinite(parsed) ? parsed : fallback;
        };

        const toBool = (value) => {
            if (typeof value === "boolean") return value;
            if (typeof value === "string") {
                const normalized = value.trim().toLowerCase();
                return normalized === "1" || normalized === "true" || normalized === "yes";
            }
            return Boolean(value);
        };

        const normalizePull = (item) => ({
            pool_id: String(item?.pool_id ?? item?.poolId ?? "UNKNOWN"),
            pool_name: String(item?.pool_name ?? item?.poolName ?? ""),
            char_id: String(item?.char_id ?? item?.charId ?? ""),
            char_name: String(item?.char_name ?? item?.charName ?? ""),
            rarity: toInt(item?.rarity, 0),
            is_free: toBool(item?.is_free ?? item?.isFree),
            is_new: toBool(item?.is_new ?? item?.isNew),
            gacha_ts: toInt(item?.gacha_ts ?? item?.gachaTs, 0) || null,
            seq_id: toInt(item?.seq_id ?? item?.seqId, 0),
            source_pool_type: String(item?.source_pool_type ?? item?._source_pool_type ?? ""),
        });

        const normalizeSession = (session, fallbackIndex = 0) => {
            const rawPulls = Array.isArray(session?.pulls)
                ? session.pulls
                : (Array.isArray(session?.items) ? session.items : []);
            const dedupe = new Map();
            rawPulls.forEach((item, index) => {
                const normalized = normalizePull(item);
                const key = [
                    normalized.seq_id || `idx-${index}`,
                    normalized.pool_id,
                    normalized.gacha_ts || "",
                    normalized.char_id || normalized.char_name || "",
                ].join(":");
                if (!dedupe.has(key)) dedupe.set(key, normalized);
            });
            const pulls = Array.from(dedupe.values()).sort((a, b) => b.seq_id - a.seq_id);

            return {
                source_session_id: String(session?.source_session_id ?? session?.id ?? `local-${Date.now()}-${fallbackIndex}`),
                created_at: String(session?.created_at ?? new Date().toISOString()),
                server_id: String(session?.server_id ?? "3"),
                lang: String(session?.lang ?? "ru-ru"),
                status: String(session?.status ?? "done"),
                error: String(session?.error ?? ""),
                pulls,
            };
        };

        const normalizePayload = (payload) => {
            if (!payload || typeof payload !== "object") return null;
            let rawSessions = Array.isArray(payload.sessions) ? payload.sessions : [];
            if (!rawSessions.length && Array.isArray(payload.items)) {
                rawSessions = [
                    {
                        source_session_id: `legacy-${Date.now()}`,
                        created_at: new Date().toISOString(),
                        server_id: "3",
                        lang: "ru-ru",
                        status: "done",
                        error: "",
                        pulls: payload.items,
                    },
                ];
            }
            const sessions = rawSessions.map((session, index) => normalizeSession(session, index));
            const pullCount = sessions.reduce((total, session) => total + (session.pulls?.length || 0), 0);
            return {
                schema_version: 1,
                exported_at: String(payload.exported_at ?? new Date().toISOString()),
                session_count: sessions.length,
                pull_count: pullCount,
                sessions,
            };
        };

        const readPayload = () => {
            try {
                const raw = localStorage.getItem(HISTORY_KEY);
                if (raw) return normalizePayload(JSON.parse(raw));
                for (const key of LEGACY_HISTORY_KEYS) {
                    const legacyRaw = localStorage.getItem(key);
                    if (!legacyRaw) continue;
                    const normalized = normalizePayload(JSON.parse(legacyRaw));
                    if (normalized) {
                        localStorage.setItem(HISTORY_KEY, JSON.stringify(normalized));
                        return normalized;
                    }
                }
                return null;
            } catch (_) {
                return null;
            }
        };

        const writePayload = (payload, reason = "update") => {
            const normalized = normalizePayload(payload);
            if (!normalized) return null;
            try {
                localStorage.setItem(HISTORY_KEY, JSON.stringify(normalized));
            } catch (_) {
                return null;
            }
            window.dispatchEvent(new CustomEvent("endfieldpass:history-updated", { detail: { reason } }));
            return normalized;
        };

        const getLatestSession = (payload = null) => {
            const current = payload || readPayload();
            if (!current || !Array.isArray(current.sessions) || !current.sessions.length) return null;
            const sorted = [...current.sessions].sort((a, b) => String(b.created_at || "").localeCompare(String(a.created_at || "")));
            return sorted[0] || null;
        };

        const getLatestPulls = (payload = null) => {
            const session = getLatestSession(payload);
            return Array.isArray(session?.pulls) ? session.pulls : [];
        };

        const upsertImportedSession = ({ server_id = "3", lang = "ru-ru", page_url = "", pulls = [] } = {}) => {
            const current = readPayload() || {
                schema_version: 1,
                exported_at: new Date().toISOString(),
                session_count: 0,
                pull_count: 0,
                sessions: [],
            };
            const nextSession = normalizeSession(
                {
                    source_session_id: `local-${Date.now()}`,
                    created_at: new Date().toISOString(),
                    server_id,
                    lang,
                    status: "done",
                    error: "",
                    page_url,
                    pulls,
                },
                0
            );
            const sessions = [nextSession, ...current.sessions].slice(0, 40);
            const merged = normalizePayload({
                schema_version: 1,
                exported_at: new Date().toISOString(),
                sessions,
            });
            return writePayload(merged, "import");
        };

        const payloadTimestamp = (payload) => {
            const normalized = normalizePayload(payload);
            if (!normalized) return 0;
            const exportedTs = Date.parse(normalized.exported_at || "");
            if (Number.isFinite(exportedTs)) return exportedTs;
            const latest = getLatestSession(normalized);
            const createdTs = Date.parse(latest?.created_at || "");
            return Number.isFinite(createdTs) ? createdTs : 0;
        };

        const payloadHasHistory = (payload) => {
            const normalized = normalizePayload(payload);
            if (!normalized) return false;
            if ((normalized.pull_count || 0) > 0) return true;
            return (normalized.sessions || []).some((session) => Array.isArray(session.pulls) && session.pulls.length > 0);
        };

        const requestJson = async (url, options = {}) => {
            const response = await fetch(url, options);
            if (!response.ok) {
                throw new Error(await response.text());
            }
            return response.json();
        };

        const getConnectedProviders = async () => {
            const result = await requestJson("/api/cloud/providers", { cache: "no-store" });
            return Array.isArray(result.providers) ? result.providers : [];
        };

        const chooseProvider = (providers) => {
            if (!providers.length) return "";
            const preferred = String(localStorage.getItem(CLOUD_PROVIDER_KEY) || "").trim().toLowerCase();
            const selected = providers.includes(preferred) ? preferred : providers[0];
            try {
                localStorage.setItem(CLOUD_PROVIDER_KEY, selected);
            } catch (_) {}
            return selected;
        };

        const importFromCloud = async (provider) => {
            const result = await requestJson("/api/cloud/auto/import", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ provider }),
            });
            return normalizePayload(result.payload);
        };

        const exportToCloud = async (provider, payload) => {
            return requestJson("/api/cloud/auto/export", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ provider, payload }),
            });
        };

        const shouldRunAutoSync = (force = false) => {
            if (force) return true;
            let lastTs = 0;
            try {
                lastTs = toInt(sessionStorage.getItem(LAST_SYNC_TS_KEY), 0);
            } catch (_) {
                return true;
            }
            if (Date.now() - lastTs < AUTO_SYNC_COOLDOWN_MS) return false;
            try {
                sessionStorage.setItem(LAST_SYNC_TS_KEY, String(Date.now()));
            } catch (_) {}
            return true;
        };

        const syncWithCloud = async ({ force = false, preferPush = false } = {}) => {
            if (!shouldRunAutoSync(force)) return { ok: true, skipped: true };

            const providers = await getConnectedProviders();
            const provider = chooseProvider(providers);
            if (!provider) return { ok: true, skipped: true, reason: "no_provider" };

            const localPayload = readPayload();
            const hasLocalHistory = payloadHasHistory(localPayload);
            if (hasLocalHistory) {
                if (!preferPush) {
                    return { ok: true, provider, skipped: true, reason: "local_first" };
                }
                await exportToCloud(provider, localPayload);
                return { ok: true, provider, action: "push" };
            }

            let remotePayload = null;
            try {
                remotePayload = await importFromCloud(provider);
            } catch (_) {
                remotePayload = null;
            }

            if (payloadHasHistory(remotePayload)) {
                writePayload(remotePayload, "cloud_pull");
                return { ok: true, provider, action: "pull" };
            }

            if (preferPush && localPayload) {
                await exportToCloud(provider, localPayload);
                return { ok: true, provider, action: "push_empty" };
            }

            return { ok: true, provider, skipped: true, reason: "no_history_anywhere" };
        };

        window.endfieldPassHistory = {
            historyKey: HISTORY_KEY,
            readPayload,
            writePayload,
            normalizePayload,
            normalizeSession,
            normalizePull,
            getLatestSession,
            getLatestPulls,
            upsertImportedSession,
            syncWithCloud,
        };

        window.addEventListener("DOMContentLoaded", () => {
            if (!window.navigator.onLine) return;
            syncWithCloud().catch(() => {});
        });
    })();
    </script>
</body>
</html>
