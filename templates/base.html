{% load static i18n_tags %}
<!DOCTYPE html>
<html lang="{{ current_lang }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}EndfieldPass{% endblock %}</title>
    <link rel="icon" type="image/png" href="{% static 'img/logo.png' %}">
    <link rel="apple-touch-icon" href="{% static 'img/logo.png' %}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{% static 'css/main.css' %}">
</head>
<body
    data-maintenance-bypass-url="{% url 'maintenance_bypass' %}"
    data-maintenance-url="{% url 'maintenance_page' %}"
    data-cloud-providers-url="{% url 'cloud_connected_providers_api' %}"
    data-cloud-auto-import-url="{% url 'cloud_auto_import_api' %}"
    data-cloud-auto-export-url="{% url 'cloud_auto_export_api' %}"
>
    <div class="layout">
        <aside class="sidebar">
            <div class="brand">
                <a href="{% url 'dashboard' %}" class="brand-link" aria-label="EndfieldPass">
                    <img src="{% static 'img/logo.png' %}" alt="EndfieldPass" class="brand-logo">
                </a>
                <div class="brand-text">
                    <span class="brand-sub">Endfield</span>
                    <span class="brand-main">Pass</span>
                </div>
            </div>
            <nav class="menu">
                <a href="{% url 'dashboard' %}" class="menu-item {% if request.resolver_match.url_name == 'dashboard' %}active{% endif %}">{% t "menu.home" %}</a>
                <a href="{% url 'characters_page' %}" class="menu-item {% if request.resolver_match.url_name == 'characters_page' %}active{% endif %}">{% t "menu.characters" %}</a>
                <a href="{% url 'weapons_page' %}" class="menu-item {% if request.resolver_match.url_name == 'weapons_page' %}active{% endif %}">{% t "menu.weapons" %}</a>
                <a href="{% url 'import_page' %}" class="menu-item {% if request.resolver_match.url_name == 'import_page' or request.resolver_match.url_name == 'import_view' %}active{% endif %}">{% t "menu.import" %}</a>
                <a href="{% url 'settings_page' %}" class="menu-item {% if request.resolver_match.url_name == 'settings_page' or request.resolver_match.url_name == 'import_history' or request.resolver_match.url_name == 'cloud_connect' or request.resolver_match.url_name == 'cloud_callback' or request.resolver_match.url_name == 'cloud_disconnect' or request.resolver_match.url_name == 'cloud_export' or request.resolver_match.url_name == 'cloud_import' %}active{% endif %}">{% t "menu.settings" %}</a>
            </nav>
            <div class="sidebar-footer">
                <form method="post" action="{% url 'set_site_language' %}" class="language-form">
                    {% csrf_token %}
                    <input type="hidden" name="next" value="{{ request.get_full_path }}">
                    <label for="site-language" class="language-label">{% t "language.selector" %}</label>
                    <select id="site-language" name="lang" onchange="this.form.submit()">
                        {% for option in language_options %}
                        <option value="{{ option.code }}" {% if current_lang == option.code %}selected{% endif %}>{{ option.label }}</option>
                        {% endfor %}
                    </select>
                </form>
            </div>
        </aside>

        <main class="content">
            <div class="content-body">
                {% block content %}{% endblock %}
            </div>
            <footer class="site-footer">
                <div class="site-footer-meta">
                    <span class="site-footer-title">EndfieldPass</span>
                    <span class="site-footer-copy">Â© 2026 Overl1te</span>
                </div>
                <nav class="site-footer-links" aria-label="{% t 'footer.aria' %}">
                    <a href="{{ repository_url }}" target="_blank" rel="noopener noreferrer">GitHub</a>
                    <a href="{% url 'privacy_policy' %}">{% t "footer.privacy" %}</a>
                    <a href="{% url 'cookies_policy' %}">{% t "footer.cookies" %}</a>
                </nav>
            </footer>
        </main>
    </div>
    <aside class="cookie-banner" id="cookieBanner" hidden>
        <p class="cookie-banner-text">{% t "cookies.p1" %}</p>
        <div class="cookie-banner-actions">
            <a href="{% url 'cookies_policy' %}" class="btn btn-outline">{% t "footer.cookies" %}</a>
            <button type="button" class="btn" id="cookieAcceptBtn">{% t "common.ok" %}</button>
        </div>
    </aside>
    <script>
    (() => {
        const CONSENT_KEY = "endfieldpass:cookie_consent_v1";
        const banner = document.getElementById("cookieBanner");
        const acceptButton = document.getElementById("cookieAcceptBtn");
        if (!banner || !acceptButton) return;

        let hasConsent = false;
        try {
            hasConsent = Boolean(localStorage.getItem(CONSENT_KEY));
        } catch (_) {
            hasConsent = false;
        }

        if (!hasConsent) {
            banner.hidden = false;
        }

        acceptButton.addEventListener("click", () => {
            try {
                localStorage.setItem(CONSENT_KEY, new Date().toISOString());
            } catch (_) {}
            banner.hidden = true;
        });
    })();
    </script>
    <script>
    (() => {
        const root = document.body;
        const bypassUrl = String(root?.dataset?.maintenanceBypassUrl || "/maintenance/bypass");
        const maintenanceUrl = String(root?.dataset?.maintenanceUrl || "/maintenance/");
        const isTruthy = (value) => {
            const normalized = String(value || "").trim().toLowerCase();
            return normalized === "1" || normalized === "true" || normalized === "yes" || normalized === "on";
        };
        const readAdminFlag = () => {
            try {
                return isTruthy(localStorage.getItem("admin"));
            } catch (_) {
                return false;
            }
        };
        const getCurrentPath = () => `${window.location.pathname || "/"}${window.location.search || ""}`;
        const normalizePath = (value) => {
            const text = String(value || "/").trim();
            if (!text) return "/";
            return text.endsWith("/") ? text.slice(0, -1) || "/" : text;
        };
        const syncMaintenanceBypass = async () => {
            if (!window.fetch) return;
            const localAdmin = readAdminFlag();
            const currentPath = getCurrentPath();
            const separator = bypassUrl.includes("?") ? "&" : "?";
            const url = `${bypassUrl}${separator}json=1&enable=${localAdmin ? "1" : "0"}&next=${encodeURIComponent(currentPath)}`;
            const response = await fetch(url, {
                cache: "no-store",
                headers: {
                    "X-Requested-With": "XMLHttpRequest",
                },
            });
            if (!response.ok) return;
            const payload = await response.json();
            if (localAdmin) return;
            if (!payload?.maintenance_enabled) return;

            const currentRoot = normalizePath(window.location.pathname || "/");
            const maintenanceRoot = normalizePath(payload?.maintenance_url || maintenanceUrl);
            if (currentRoot === maintenanceRoot || currentRoot.startsWith(`${maintenanceRoot}/`)) return;

            const targetSeparator = String(maintenanceUrl).includes("?") ? "&" : "?";
            const target = `${maintenanceUrl}${targetSeparator}next=${encodeURIComponent(currentPath)}`;
            window.location.replace(target);
        };

        window.addEventListener("DOMContentLoaded", () => {
            syncMaintenanceBypass().catch(() => {});
        });
    })();
    </script>
    <script>
    (() => {
        const HISTORY_KEY = "endfieldpass:history_payload_v1";
        const LEGACY_HISTORY_KEYS = ["endfieldpass:history_payload"];
        const CLOUD_PROVIDER_KEY = "endfieldpass:cloud_provider";
        const LAST_SYNC_TS_KEY = "endfieldpass:last_auto_sync_ts";
        const AUTO_SYNC_COOLDOWN_MS = 25000;
        const root = document.body;
        const cloudProvidersUrl = String(root?.dataset?.cloudProvidersUrl || "{% url 'cloud_connected_providers_api' %}");
        const cloudAutoImportUrl = String(root?.dataset?.cloudAutoImportUrl || "{% url 'cloud_auto_import_api' %}");
        const cloudAutoExportUrl = String(root?.dataset?.cloudAutoExportUrl || "{% url 'cloud_auto_export_api' %}");

        const toInt = (value, fallback = 0) => {
            const parsed = Number.parseInt(String(value ?? ""), 10);
            return Number.isFinite(parsed) ? parsed : fallback;
        };

        const toBool = (value) => {
            if (typeof value === "boolean") return value;
            if (typeof value === "string") {
                const normalized = value.trim().toLowerCase();
                return normalized === "1" || normalized === "true" || normalized === "yes";
            }
            return Boolean(value);
        };

        const normalizeSeqId = (value) => String(value ?? "").trim();
        const normalizePullKeyPart = (value) => String(value ?? "").trim().toLowerCase();

        const toBigIntOrNull = (value) => {
            const source = normalizeSeqId(value);
            if (!source) return null;
            try {
                return BigInt(source);
            } catch (_) {
                return null;
            }
        };

        const comparePullsDesc = (left, right) => {
            const tsDelta = (toInt(right?.gacha_ts, 0) - toInt(left?.gacha_ts, 0));
            if (tsDelta !== 0) return tsDelta;

            const leftSeqBig = toBigIntOrNull(left?.seq_id);
            const rightSeqBig = toBigIntOrNull(right?.seq_id);
            if (leftSeqBig !== null && rightSeqBig !== null && leftSeqBig !== rightSeqBig) {
                return rightSeqBig > leftSeqBig ? 1 : -1;
            }

            const seqDelta = toInt(right?.seq_id, 0) - toInt(left?.seq_id, 0);
            if (seqDelta !== 0) return seqDelta;

            return String(right?.pool_id || "").localeCompare(String(left?.pool_id || ""));
        };

        const buildPullDedupeKey = (pull, fallbackIndex = 0) => {
            const poolId = normalizePullKeyPart(pull?.pool_id);
            const seqId = normalizeSeqId(pull?.seq_id);
            if (poolId && seqId) {
                return `seq:${poolId}:${seqId}`;
            }

            const timestamp = toInt(pull?.gacha_ts, 0);
            const typeKey = normalizePullKeyPart(pull?.item_type);
            const unitKey =
                normalizePullKeyPart(pull?.weapon_id)
                || normalizePullKeyPart(pull?.char_id)
                || normalizePullKeyPart(pull?.char_name)
                || "unit";
            // Keep fallback records unique per payload order to avoid collapsing duplicate pulls.
            return `fallback:${poolId}:${timestamp}:${typeKey}:${unitKey}:idx-${fallbackIndex}`;
        };

        const mergePullRecords = (current, incoming) => {
            if (!current) return incoming;
            const merged = { ...current };
            const preferIncoming = (field) => {
                if (!String(merged[field] ?? "").trim() && String(incoming[field] ?? "").trim()) {
                    merged[field] = incoming[field];
                }
            };
            preferIncoming("pool_name");
            preferIncoming("char_id");
            preferIncoming("char_name");
            preferIncoming("source_pool_type");
            preferIncoming("item_type");
            preferIncoming("weapon_id");
            preferIncoming("weapon_name");

            if (!toInt(merged.gacha_ts, 0) && toInt(incoming.gacha_ts, 0)) {
                merged.gacha_ts = incoming.gacha_ts;
            }
            if (!normalizeSeqId(merged.seq_id) && normalizeSeqId(incoming.seq_id)) {
                merged.seq_id = incoming.seq_id;
            }
            if (!toInt(merged.rarity, 0) && toInt(incoming.rarity, 0)) {
                merged.rarity = incoming.rarity;
            }
            return merged;
        };

        const inferItemType = (item, sourcePoolType, poolId, weaponId, weaponName) => {
            const explicit = String(item?.item_type ?? item?.itemType ?? "").trim().toLowerCase();
            if (explicit === "weapon" || explicit === "character") return explicit;
            const sourceHint = String(sourcePoolType || "").trim().toLowerCase();
            const poolHint = String(poolId || "").trim().toLowerCase();
            if (weaponId || weaponName) return "weapon";
            if (sourceHint.includes("weapon")) return "weapon";
            if (poolHint.includes("weapon") || poolHint.includes("weponbox")) return "weapon";
            return "character";
        };

        const normalizePull = (item) => {
            const poolId = String(item?.pool_id ?? item?.poolId ?? "UNKNOWN");
            const sourcePoolType = String(item?.source_pool_type ?? item?._source_pool_type ?? "");
            const weaponId = String(item?.weapon_id ?? item?.weaponId ?? "");
            const weaponName = String(item?.weapon_name ?? item?.weaponName ?? "");
            return {
                pool_id: poolId,
                pool_name: String(item?.pool_name ?? item?.poolName ?? ""),
                char_id: String(item?.char_id ?? item?.charId ?? weaponId),
                char_name: String(item?.char_name ?? item?.charName ?? weaponName),
                rarity: toInt(item?.rarity, 0),
                is_free: toBool(item?.is_free ?? item?.isFree),
                is_new: toBool(item?.is_new ?? item?.isNew),
                gacha_ts: toInt(item?.gacha_ts ?? item?.gachaTs, 0) || null,
                seq_id: normalizeSeqId(item?.seq_id ?? item?.seqId),
                source_pool_type: sourcePoolType,
                item_type: inferItemType(item, sourcePoolType, poolId, weaponId, weaponName),
                weapon_id: weaponId,
                weapon_name: weaponName,
            };
        };

        const normalizeSession = (session, fallbackIndex = 0) => {
            const rawPulls = Array.isArray(session?.pulls)
                ? session.pulls
                : (Array.isArray(session?.items) ? session.items : []);
            const dedupe = new Map();
            rawPulls.forEach((item, index) => {
                const normalized = normalizePull(item);
                const key = buildPullDedupeKey(normalized, index);
                dedupe.set(key, mergePullRecords(dedupe.get(key), normalized));
            });
            const pulls = Array.from(dedupe.values()).sort(comparePullsDesc);

            return {
                source_session_id: String(session?.source_session_id ?? session?.id ?? `local-${Date.now()}-${fallbackIndex}`),
                created_at: String(session?.created_at ?? new Date().toISOString()),
                server_id: String(session?.server_id ?? "3"),
                lang: String(session?.lang ?? "ru-ru"),
                status: String(session?.status ?? "done"),
                error: String(session?.error ?? ""),
                pulls,
            };
        };

        const normalizePayload = (payload) => {
            if (!payload || typeof payload !== "object") return null;
            let rawSessions = Array.isArray(payload.sessions) ? payload.sessions : [];
            if (!rawSessions.length && Array.isArray(payload.items)) {
                rawSessions = [
                    {
                        source_session_id: `legacy-${Date.now()}`,
                        created_at: new Date().toISOString(),
                        server_id: "3",
                        lang: "ru-ru",
                        status: "done",
                        error: "",
                        pulls: payload.items,
                    },
                ];
            }
            const sessions = rawSessions.map((session, index) => normalizeSession(session, index));
            const pullCount = sessions.reduce((total, session) => total + (session.pulls?.length || 0), 0);
            return {
                schema_version: 1,
                exported_at: String(payload.exported_at ?? new Date().toISOString()),
                session_count: sessions.length,
                pull_count: pullCount,
                sessions,
            };
        };

        const readPayload = () => {
            try {
                const raw = localStorage.getItem(HISTORY_KEY);
                if (raw) return normalizePayload(JSON.parse(raw));
                for (const key of LEGACY_HISTORY_KEYS) {
                    const legacyRaw = localStorage.getItem(key);
                    if (!legacyRaw) continue;
                    const normalized = normalizePayload(JSON.parse(legacyRaw));
                    if (normalized) {
                        localStorage.setItem(HISTORY_KEY, JSON.stringify(normalized));
                        return normalized;
                    }
                }
                return null;
            } catch (_) {
                return null;
            }
        };

        const writePayload = (payload, reason = "update") => {
            const normalized = normalizePayload(payload);
            if (!normalized) return null;
            try {
                localStorage.setItem(HISTORY_KEY, JSON.stringify(normalized));
            } catch (_) {
                return null;
            }
            window.dispatchEvent(new CustomEvent("endfieldpass:history-updated", { detail: { reason } }));
            return normalized;
        };

        const getLatestSession = (payload = null) => {
            const current = payload || readPayload();
            if (!current || !Array.isArray(current.sessions) || !current.sessions.length) return null;
            const sorted = [...current.sessions].sort((a, b) => String(b.created_at || "").localeCompare(String(a.created_at || "")));
            return sorted[0] || null;
        };

        const getLatestPulls = (payload = null) => {
            const session = getLatestSession(payload);
            return Array.isArray(session?.pulls) ? session.pulls : [];
        };

        const getAllPulls = (payload = null) => {
            const current = payload || readPayload();
            if (!current || !Array.isArray(current.sessions) || !current.sessions.length) return [];

            const dedupe = new Map();
            current.sessions.forEach((session) => {
                const pulls = Array.isArray(session?.pulls) ? session.pulls : [];
                pulls.forEach((pull, index) => {
                    const normalized = normalizePull(pull);
                    const key = buildPullDedupeKey(normalized, index);
                    dedupe.set(key, mergePullRecords(dedupe.get(key), normalized));
                });
            });

            return Array.from(dedupe.values()).sort(comparePullsDesc);
        };

        const upsertImportedSession = ({ server_id = "3", lang = "ru-ru", page_url = "", pulls = [] } = {}) => {
            const current = readPayload() || {
                schema_version: 1,
                exported_at: new Date().toISOString(),
                session_count: 0,
                pull_count: 0,
                sessions: [],
            };
            const nextSession = normalizeSession(
                {
                    source_session_id: `local-${Date.now()}`,
                    created_at: new Date().toISOString(),
                    server_id,
                    lang,
                    status: "done",
                    error: "",
                    page_url,
                    pulls,
                },
                0
            );
            const sessions = [nextSession, ...current.sessions].slice(0, 40);
            const merged = normalizePayload({
                schema_version: 1,
                exported_at: new Date().toISOString(),
                sessions,
            });
            return writePayload(merged, "import");
        };

        const payloadTimestamp = (payload) => {
            const normalized = normalizePayload(payload);
            if (!normalized) return 0;
            const exportedTs = Date.parse(normalized.exported_at || "");
            if (Number.isFinite(exportedTs)) return exportedTs;
            const latest = getLatestSession(normalized);
            const createdTs = Date.parse(latest?.created_at || "");
            return Number.isFinite(createdTs) ? createdTs : 0;
        };

        const payloadHasHistory = (payload) => {
            const normalized = normalizePayload(payload);
            if (!normalized) return false;
            if ((normalized.pull_count || 0) > 0) return true;
            return (normalized.sessions || []).some((session) => Array.isArray(session.pulls) && session.pulls.length > 0);
        };

        const requestJson = async (url, options = {}) => {
            const response = await fetch(url, options);
            if (!response.ok) {
                throw new Error(await response.text());
            }
            return response.json();
        };

        const getConnectedProviders = async () => {
            const result = await requestJson(cloudProvidersUrl, { cache: "no-store" });
            return Array.isArray(result.providers) ? result.providers : [];
        };

        const chooseProvider = (providers) => {
            if (!providers.length) return "";
            const preferred = String(localStorage.getItem(CLOUD_PROVIDER_KEY) || "").trim().toLowerCase();
            const selected = providers.includes(preferred) ? preferred : providers[0];
            try {
                localStorage.setItem(CLOUD_PROVIDER_KEY, selected);
            } catch (_) {}
            return selected;
        };

        const importFromCloud = async (provider) => {
            const result = await requestJson(cloudAutoImportUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ provider }),
            });
            return normalizePayload(result.payload);
        };

        const exportToCloud = async (provider, payload) => {
            return requestJson(cloudAutoExportUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ provider, payload }),
            });
        };

        const shouldRunAutoSync = (force = false) => {
            if (force) return true;
            let lastTs = 0;
            try {
                lastTs = toInt(sessionStorage.getItem(LAST_SYNC_TS_KEY), 0);
            } catch (_) {
                return true;
            }
            if (Date.now() - lastTs < AUTO_SYNC_COOLDOWN_MS) return false;
            try {
                sessionStorage.setItem(LAST_SYNC_TS_KEY, String(Date.now()));
            } catch (_) {}
            return true;
        };

        const syncWithCloud = async ({ force = false, preferPush = false } = {}) => {
            if (!shouldRunAutoSync(force)) return { ok: true, skipped: true };

            const providers = await getConnectedProviders();
            const provider = chooseProvider(providers);
            if (!provider) return { ok: true, skipped: true, reason: "no_provider" };

            const localPayload = readPayload();
            const hasLocalHistory = payloadHasHistory(localPayload);
            if (hasLocalHistory) {
                if (!preferPush) {
                    return { ok: true, provider, skipped: true, reason: "local_first" };
                }
                await exportToCloud(provider, localPayload);
                return { ok: true, provider, action: "push" };
            }

            let remotePayload = null;
            try {
                remotePayload = await importFromCloud(provider);
            } catch (_) {
                remotePayload = null;
            }

            if (payloadHasHistory(remotePayload)) {
                writePayload(remotePayload, "cloud_pull");
                return { ok: true, provider, action: "pull" };
            }

            if (preferPush && localPayload) {
                await exportToCloud(provider, localPayload);
                return { ok: true, provider, action: "push_empty" };
            }

            return { ok: true, provider, skipped: true, reason: "no_history_anywhere" };
        };

        window.endfieldPassHistory = {
            historyKey: HISTORY_KEY,
            readPayload,
            writePayload,
            normalizePayload,
            normalizeSession,
            normalizePull,
            getAllPulls,
            getLatestSession,
            getLatestPulls,
            upsertImportedSession,
            syncWithCloud,
        };

        window.addEventListener("DOMContentLoaded", () => {
            if (!window.navigator.onLine) return;
            syncWithCloud().catch(() => {});
        });
    })();
    </script>
</body>
</html>
